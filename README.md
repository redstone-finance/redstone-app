## Classic Layer
### Getting Started
The Classic Layer uses Etherscan as a data source for charts as well as a provider for the ethers.js library. To make it work, we need to provide an API key. Copy the `example.env` file and save it as `.env`, then provide the API key for the `VUE_APP_ETHER_SCAN_API_KEY` environment variable.

### Challenges During Development
While investigating blockchains, data sources for layers, and the ethers.js library, I discovered that not all contracts expose ABI interfaces. This is likely related to a lack of knowledge about different providers and other blockchains. Another issue is the massive number of API calls the ethers.js library makes. Everything works asynchronously, so I decided to create many loaders and fetch data asynchronously for each contract. I tried to showcase various ways to interact with data, such as copying, bulk actions, and exploring addresses in Etherscan in case of fetch errors. There are many console logs generated by the data layer stored inside the store. In conclusion, this was a very interesting project, and I would love to delve deeper into the blockchain world.

### General Overview of the Solution

* All contract behavior is located in the `layers.js` store file. Fetching, saving, and handling loaders are all managed there.
* `Layers.vue` and `Layer.vue` are views that interact with the data from the store. There were many challenges with the Bootstrap library, so I had to write some additional code to achieve my goals.
* I created some helper files located in the `src/core` directory for tasks we don't necessarily want to handle within the components.
* The styling is mostly done with the BEM approach. However, I would consider refactoring the whole thing due to the development process. I've tinkered with the UI a lot, so there are many opportunities for improvement.
* I created multiple subcomponents for parts that were either too big to keep within the view file or that I wanted to reuse in other views. In the future, I would seriously consider extracting the table into a separate component because it is the biggest and most code-consuming element. The view should just be responsible for implementing components, not for containing much business logic - that's something for the future, I hope!


#### Research

Regarding the last point about fetching logos and other UI elements for specific chains and providers I did some digging and I would say that the best way would be to keep and maintain own list of resources. There is no one solution which provides all logos etc, so most likely we would like to have some small app/ backend service which either accumulates and maps assets. 